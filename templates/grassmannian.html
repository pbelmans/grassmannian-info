{% extends "page.html" %}

{% import "macros.html" as macros %}

{% block title %}{{ G.name() }} {{ G.plaintext() | safe }}{% endblock %}


{% macro basic(G) %}
<dl class="row">
  <dt class="col-3 text-right">dimension
  <dd class="col-9">{{ G.dimension() }}

  <dt class="col-3 text-right">index
  <dd class="col-9">{{ G.index() }}

  <dt class="col-3 text-right">Euler characteristic
  <dd class="col-9">{{ G.rank() }}

  <dt class="d-lg-none col-3 text-right">Betti numbers
  <dd class="d-lg-none col-9">{{ betti_horizontal(G) }}

  <dt class="col-3 text-right">$\mathrm{Aut}^0({{ G.latex() }})$
  <dd class="col-9">{{ macros.adjoint_group(G.Aut().D) }}

  <dt class="col-3 text-right">$\pi_0\mathrm{Aut}({{ G.latex() }})$
  <dd class="col-9">${{ G.pizero() }}$

  <dt class="col-3 text-right">$\dim\mathrm{Aut}^0({{ G.latex() }})$
  <dd class="col-9">{{ G.Aut().dimension() }}
</dl>
{% endmacro %}


{% macro partition(lefschetz, embedding) %}
<svg class="lefschetz" style="max-width: {{ [embedding * 40, 800] | min }}" viewBox="0 0 {{ embedding * 20 }} {{ lefschetz["support"][0] * 20 }} ">
  {% for i in range(embedding) %}
    {% for j in range(lefschetz["support"][0]) %}
    <rect x="{{ i * 20 }}" y="{{ j * 20 }}" width="20" height="20" class="block{% if i < lefschetz["support"] | length and j < lefschetz["support"][i] %} original{% endif %} " />
    {% endfor %}
  {% endfor %}
</svg>
{% endmacro %}


{% macro hpd(G) %}
{% for lefschetz in G.lefschetz() %}
  {{ partition(lefschetz, G.embedding() + 1) }}
{% endfor %}
{% endmacro %}


{% macro QH(G) %}
<p>The <em>small</em> quantum cohomology is <strong>{% if G.small_qh_semisimple() %}generically semisimple{% elif G.small_qh_not_semisimple() %}not generically semisimple{% else %}not known to be (non-)semisimple{% endif %}</strong>.

<p>The <em>big</em> quantum cohomology is <strong>{% if G.big_qh_semisimple()%}generically semisimple{% else %}not known yet to be generically semisimple{% endif %}</strong>.

{% if G.eigenvalues() %}
<p>The eigenvalues of quantum multiplication by $\mathrm{c}_1({{ G.latex() }})$ are given by:

<div id="eigenvalues"></div>

<div class="multiplicities d-none">
  <input id="multiplicities" type="checkbox" data-toggle="toggle" data-on="show" data-off="hide" data-onstyle="secondary" data-size="xs">
  <label for="multiplicities">multiplicities
</div>


<script src="https://d3js.org/d3.v5.js"></script>
<script type="text/javascript">
$(function() {
  // toggle between no or lots of information by activating a class which triggers the styling
  $("input#multiplicities").change(function() {
    if ($(this).prop("checked"))
      $("text.multiplicities").attr("display", "none");
    else
      $("text.multiplicities").removeAttr("display");
  });
});


var margin = {top: 10, right: 30, bottom: 30, left: 60},
    width = 460 - margin.left - margin.right,
    height = 400 - margin.top - margin.bottom;

// append the svg object to the body of the page
var svg = d3.select("#eigenvalues")
  .append("svg")
    .attr("viewBox", "0 0 460 400")
  //  .attr("width", width + margin.left + margin.right)
  //  .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

var eigenvalues = [{% for e in G.eigenvalues() %}[{{ G.index() * e[0] }}, {{ G.index() * e[1] }}], {% endfor %}];

// add multiplicity
var counts = {};
eigenvalues.forEach(function(x) { counts[x] = (counts[x] || 0)+1; });

var data = [];
for (eigenvalue in counts) {
  data.push({x: parseFloat(eigenvalue.split(",")[0]), y: parseFloat(eigenvalue.split(",")[1]), multiplicity: counts[eigenvalue]});

  if (counts[eigenvalue] > 1)
    $("div.multiplicities").removeClass("d-none");
}

// determine size of box around points
var xMin = xMax = yMin = yMax = 0;
for (var i = 0; i < data.length; i++) {
  xMin = Math.min(xMin, data[i].x);
  xMax = Math.max(xMax, data[i].x);
  yMin = Math.min(yMin, data[i].y);
  yMax = Math.max(yMax, data[i].y);
}
var epsilon = 1;

// add X axis
var x = d3.scaleLinear().domain([xMin - epsilon, xMax + epsilon]).range([ 0, width ]);
var xAxis = svg.append("g").attr("transform", "translate(0," + height + ")").call(d3.axisBottom(x));

// add y axis
var y = d3.scaleLinear().domain([yMin - epsilon, yMax + epsilon]).range([ height, 0]);
var yAxis = svg.append("g").call(d3.axisLeft(y));

// add points
var points = svg.append("g")
  .selectAll("point")
  .data(data)
  .enter()
  .append("circle")
    .attr("cx", function(d) { return x(d.x); })
    .attr("cy", function(d) { return y(d.y); })
    .attr("fill", "red")
    .attr("r", function(d) { return 0.5 * d.multiplicity + 0.5; });

var multiplicities = svg.append("g")
  .selectAll("point")
  .data(data)
  .enter()
  .append("text")
    .attr("class", "multiplicities")
    .attr("x", function(d) { return x(d.x) + d.multiplicity + 1; })
    .attr("y", function(d) { return y(d.y) + 2; })
    .attr("font-size", "7px")
    .text(function(d) { return d.multiplicity > 1 ? d.multiplicity : ""; });
</script>
{% endif %}
{% endmacro %}


{% macro betti_vertical(G) %}
\begin{align*}
{%- for betti in G.betti() %}
  \mathrm{b}_{ {{ loop.index }} } &= {{ betti }} {% if not loop.last %}\\{% endif %}
{%- endfor %}
\end{align*}
{% endmacro %}

{% macro betti_horizontal(G) %}
{%- for betti in G.betti() -%}
  $\mathrm{b}_{ {{ loop.index }} } = {{ betti }}${% if not loop.last %}, {% endif %}
{%- endfor %}
{% endmacro %}


{% macro projective(G) %}
<dl class="row">
  <dt class="col-3 text-right">minimal embedding
  <dd class="col-9"><p>${{ G.latex() }}\hookrightarrow\mathbb{P}^{ {{ G.embedding() }} }$</p>
  {% if G.D.T == "C" and G.k == 1 %}<p>More appropriately in this particular presentation as a quotient of the symplectic group is to consider the Grassmannian as the <em>adjoint</em> variety of type $\mathrm{C}_{ {{ G.D.n }} }$, where the embedding is the second Veronese embedding into $\mathbb{P}(\mathrm{V}_{2\omega_1})=\mathbb{P}^{ {{ (G.embedding() * (G.embedding() + 3) / 2) | int }} }$.{% endif %}
  <dt class="col-3 text-right">degree
  <dd class="col-9">{{ G.degree() }}

  <dt class="col-3 text-right">Hilbert series
  <dd class="col-9">
    {% for dimension in G.hilbert_series() -%}
      {{- dimension -}}
      {%- if not loop.last %}, {% endif %}
    {%- endfor -%}, ...
</dl>
{% endmacro %}


{% macro exceptional_sequence(G, sequence) %}
<li>{{ sequence[0] | safe }} constructed a full exceptional sequence in {{ sequence[1] }}, see {{ macros.reference_link(sequence[2]) }}.
{% endmacro %}


{% macro exceptional_sequences(G) %}
{% if G.exceptional_sequences() | length == 0 %}
  <p>No full exceptional collection is known for $\mathbf{D}^{\mathrm{b}}({{ G.latex() }})$. Will you be the first to construct one? Let us know if you do!

  {% if G.D.T in ["A", "B", "C", "D"] %}
    <p>Kuznetsov&ndash;Polishchuk have constructed an exceptional collection of maximal length in <a href="https://mathscinet.ams.org/mathscinet-getitem?mr=3463417">MR3463417</a>. Can you prove it's full?
  {% endif %}
{% else %}
  <ul>
  {% for sequence in G.exceptional_sequences() %}
    {{ exceptional_sequence(G, sequence) }}
  {% endfor %}
  </ul>
{% endif %}
{% endmacro %}


{% block content %}
<header class="text-center">
  <h2 class="mt-3">{{ G.name()[0] | upper  }}{{ G.name()[1:] | safe }}
    {% if G.D.T in ["A", "B", "C", "D"] or (G.D.D, G.k) in [("E6", 1), ("E6", 6)] or (G.D.D, G.k) == ("G2", 1) %}
      ${{ G.latex() }}$
    {% endif %}
  </h2>

  {{ macros.dynkin(G.D.T, G.D.n, height=100, k=[G.k]) }}
</header>

{% if G.isomorphisms() | length >= 2 %}
  <div class="col mb-5">
    There exist other realisations of this Grassmannian:
    <ul>
      {% for (D, k) in G.isomorphisms() if (D, k) != (G.D.D, G.k) %}
      <li><a href="/{{ D }}/{{ k }}">{{ macros.dynkin(D[0], D[1:] | int, height=40, k=[k]) }}</a>
      {% endfor %}
    </ul>
  </div>
{% endif %}

<div class="row">
  <div class="col-2 d-none d-lg-block">
    {{ macros.component("Betti numbers", betti_vertical(G)) }}
  </div>

  <div class="col-12 col-lg-10">
    {{ macros.component("Basic information", basic(G)) }}

    {{ macros.component("Projective geometry", projective(G)) }}

    {{ macros.component("Exceptional collections", exceptional_sequences(G)) }}

    {{ macros.component("Quantum cohomology", QH(G)) }}

    {{ macros.component("Homological projective duality", hpd(G)) }}
  </div>
</div>


<script type="text/javascript">
  $("header circle").each(function() {
    // needs to be done in plain JS, not jQuery
    var a = document.createElementNS(this.namespaceURI, "a");

    this.parentNode.insertBefore(a, this);
    a.appendChild(this);
    a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "/" + $(this).data("label").replace("-", "/"));
  });
</script>
{% endblock %}
